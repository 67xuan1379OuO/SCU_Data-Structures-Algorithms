# BFS與DFS
## 目錄
* [DFS與BFS原理與比較](#DFS與BFS原理與比較)
  * [BFS原理](#BFS原理)
  * [DFS原理](#DFS原理)
  * [BFS與DFS的比較](#BFS與DFS的比較)
* [流程圖與學習歷程](#流程圖與學習歷程)
  * [流程圖](#流程圖)
  * [學習歷程](#學習歷程)
* [參考資料](#參考資料)

## DFS與BFS原理與比較

### BFS原理

### BFS原理

### BFS與DFS的比較

## 流程圖與學習歷程
### 流程圖

### 學習歷程

因為不是很了解graph的使用方式，所以先了解一下助教規定的格式，graph會長什麼樣子、該怎麼利用，後面才方便寫出BFS與DFS程式碼～
```python
#助教規定之繳交格式
# Python3 Program to print BFS traversal 
# from a given source vertex. BFS(int s) 
# traverses vertices reachable from s. 
from collections import defaultdict 
  
# This class represents a directed graph 
# using adjacency list representation 
class Graph:
    # Constructor 
    def __init__(self): 
        # default dictionary to store graph 
        self.graph = defaultdict(list) 

    # function to add an edge to graph 
    def addEdge(self,u,v): 
        self.graph[u].append(v) 
```
使用助教測資印出後，g.graph為**defaultdict(list, {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]})** ，  
使用 **g.graph[0]** 印出結果為 **[1, 2]** ，  
所以可以看出若我們需要從這個graph中找到我們要走訪的點(n)能走訪到的值，  
可以直接打出g.graph[n]找出。  


接下來是BFS跟DFS的部分，  
我總結了一下DFS跟DFS的概念，他們都是先進行走訪後，  
將未走訪過的點加入某list中，並且依據此list的順序作為之後進行走訪的順序。  
而BFS跟DFS兩者的差別，只是在於：  
BFS是「**先進先出**」，而DFS為「**先進後出**」。  
所以我的想法是，至少需要先創建出三個list，  
一個是暫存未走訪過且待走訪的點（total），  
一個是儲存已經走訪過的點（作為未走訪過的判斷依據）（past），  
一個是儲存我們走訪的順序（ans）。  
接著從total中取出我們接下來要執行動作的點，並將該點從該list中pop除，  
並在動作的最後加入ans中。


先寫出BFS跟DFS共用的def，也就是走訪的順序判斷，  
我的想法是：  
先創建出上面說的三個list，  
並且使用for迴圈，搭配graph的使用方法，找出該節點能夠連結到的其他節點，  
並將未走訪過的節點加入past與total兩個list中，作為之後的走訪順序依據。  
以下是這個部分我的程式碼初步構想：
```python
total=[]#total要存放所有的節點 
past = [] # past要存放已經走訪過的點
ans =[] #這裏存放走訪的順序
nodes = graph[current]
#這裡的current 為目前正在進行走訪的點
#這裡的nodes為current可以走訪到的點（依據adjacency list為判斷）
def existed(self,current,nodes,past,total):
    for w in nodes: #使用for迴圈開始走訪
        if w not in past: #如果未曾走訪過該點
            total.append(w) #將該點加入queue跟past中（以作為之後走訪的順序）
            past.append(w)
    return total,past
```


另外，因為第一個點在執行DFS與BFS時，就會被走訪過，  
所以我的想法是：在程式開始執行時，就要將該點加入past跟total的list中，不管是DFS或BFS都一樣，  
所以先寫一個def來當作開始時的固定動作～  
```python
def started(self,s,total,past):
    total.append(s) #先將起點加入queue中
    past.append(s) #先將起點加入past中
    return total,past
```


接著把它們應用到BFS中試試看～  
因為BFS的概念是「先進先出」，  
所以我的想法是：  
只要total這個list中還有值，就就使用pop(0)的方式來取出我們將要進行走訪的數值並開始走訪，  
接著就是判斷該值可以連結到的點，有沒有還沒被append到我們將進行走訪的list中（也就是上面那段程式碼的部分） 
若尚未被加入則將他加入past與total這兩個list，作為之後走訪順序的依據，  
最後再將我們正在走訪的值append進入ans中，即可完成～  
以下是我的程式碼：
```python
# Python3 Program to print BFS traversal 
# from a given source vertex. BFS(int s) 
# traverses vertices reachable from s. 
from collections import defaultdict 
  
# This class represents a directed graph 
# using adjacency list representation 
class Graph:
    # Constructor 
    def __init__(self): 
        # default dictionary to store graph 
        self.graph = defaultdict(list) 

    # function to add an edge to graph 
    def addEdge(self,u,v): 
        self.graph[u].append(v) 
    
    def started(self,s,total,past):
        total.append(s) #先將起點加入queue中
        past.append(s) #先將起點加入past中
        return total,past
        
    def existed(self,current,nodes,past,total):
        for w in nodes: #使用for迴圈開始走訪
            if w not in past: #如果未曾走訪過該點
                total.append(w) #將該點加入queue跟past中（以作為之後走訪的順序）
                past.append(w)
        return total,past

    # Function to print a BFS of graph 
    def BFS(self, s): 
        graph = self.graph #先導入我們指定的圖
        total=[]#total要存放所有的節點 
        past = [] # past要存放已經走訪過的點
        ans =[] #這裏存放走訪的順序
        total,past=self.started(s,past,total)
        while total:
            current = total.pop(0) #BFS是從第一個queue中的最前面開始跑
            nodes = graph[current] #從graph中找出所有該點會連結到的點
            total,past=self.existed(current,nodes,past,total)
            if current is not None: 
                ans.append(current) #將目前走訪的點加入ans中
        return ans
```


同樣的，也可以將上面的概念應用到DFS中，如同我前面提到的，  
因為BFS跟DFS的順序只有在「先進先出」與「先進後出」的差別，  
所以BFS是pop除total中的第一個數字，DFS就是pop掉total中的最後一個數字即可，  
其他的概念都是一樣的，將目前走訪值之可連結的點加入total與past兩個list中，  
並在動作執行完成後，將正在走訪的點加入於ans中，即可完成～  
以下是我的程式碼：
```python
# Python3 Program to print BFS traversal 
# from a given source vertex. BFS(int s) 
# traverses vertices reachable from s. 
from collections import defaultdict 
  
# This class represents a directed graph 
# using adjacency list representation 
class Graph:
    # Constructor 
    def __init__(self): 
        # default dictionary to store graph 
        self.graph = defaultdict(list) 

    # function to add an edge to graph 
    def addEdge(self,u,v): 
        self.graph[u].append(v) 
    
    def started(self,s,total,past):
        total.append(s) #先將起點加入queue中
        past.append(s) #先將起點加入past中
        return total,past
        
    def existed(self,current,nodes,past,total):
        for w in nodes: #使用for迴圈開始走訪
            if w not in past: #如果未曾走訪過該點
                total.append(w) #將該點加入queue跟past中（以作為之後走訪的順序）
                past.append(w)
        return total,past
        
    # Function to print a DFS of graph 
    def DFS(self, s): 
        """
        :type s: int
        :rtype: list
        """
        graph = self.graph
        total=[]#total要存放所有的節點 
        past = [] # past要存放已經走訪過的點
        ans =[] #這裏存放走訪的順序
        total,past=self.started(s,past,total)
        while total:
            current = total.pop() # DFS是從stack中的最後一個開始跑
            nodes = graph[current] #從graph中找出所有該點會連結到的點
            total,past=self.existed(current,nodes,past,total)
            if current is not None: 
                ans.append(current) #最後將目前走訪的點加入ans中
        return ans
```


接下來，把程式碼的部分合併，HW5就大功告成拉～
```python 
from collections import defaultdict 
class Graph:
    def __init__(self): 
        self.graph = defaultdict(list) 
        
    def addEdge(self,u,v): 
        self.graph[u].append(v) 
        
    def started(self,s,total,past):
        total.append(s) #先將起點加入queue中
        past.append(s) #先將起點加入past中
        return total,past
        
    def existed(self,current,nodes,past,total):
        for w in nodes: #使用for迴圈開始走訪
            if w not in past: #如果未曾走訪過該點
                total.append(w) #將該點加入queue跟past中（以作為之後走訪的順序）
                past.append(w)
        return total,past
        
    def BFS(self, s): 
        graph = self.graph #先導入我們指定的圖
        total=[]#total要存放所有的節點 
        past = [] # past要存放已經走訪過的點
        ans =[] #這裏存放走訪的順序
        total,past=self.started(s,past,total)
        while total:
            current = total.pop(0) #BFS是從第一個queue中的最前面開始跑
            nodes = graph[current] #從graph中找出所有該點會連結到的點
            total,past=self.existed(current,nodes,past,total)
            if current is not None: 
                ans.append(current) #將目前走訪的點加入ans中
        return ans
        
    def DFS(self, s): 
        graph = self.graph
        total=[]#total要存放所有的節點 
        past = [] # past要存放已經走訪過的點
        ans =[] #這裏存放走訪的順序
        total,past=self.started(s,past,total)
        while total:
            current = total.pop() # DFS是從stack中的最後一個開始跑
            nodes = graph[current] #從graph中找出所有該點會連結到的點
            total,past=self.existed(current,nodes,past,total)
            if current is not None: 
                ans.append(current) #最後將目前走訪的點加入ans中
        return ans
```
## 參考資料
[Graph: Breadth-First Search(BFS，廣度優先搜尋)](http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html#algorithm)
[演算法筆記- Graph - 網路郵局](http://www.csie.ntnu.edu.tw/~u91029/Graph.html)
[(DFS)和廣度優先搜尋(BFS) - MagicLen](https://magiclen.org/dfs-bfs/)
