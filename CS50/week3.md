# CS50 - Week3

## Contents
* [演算法的時間複雜度(Time Complexity)](#演算法的時間複雜度Time_Complexity)
* [Sorting排序](#Sorting排序)
  * [Bubble Sort](#Bubble_Sort)
  * [Selection Sort](#Selection_Sort)
  * [Insertion Sort](#Insertion_Sort)
* [O與Ω符號](#O與Ω符號)
* [Reference](#Reference)


## 演算法的時間複雜度Time_Complexity
* **時間複雜度？**：一個描述演算法執行時間的函式。常用大O符號表述。
  * 相同大小的不同輸入值仍可能造成演算法的執行時間不同，因此我們通常使用演算法的**最壞情況複雜度**。
  * **平均情況複雜度**，通常較少使用，通常有特別指定才會使用。
  * **O表示最壞情況下的運行時間，Ω代表最佳情況下的運行時間。**

而時間複雜度的比較如下圖：  


![image](http://cdn.cs50.net/2013/fall/lectures/3/w/notes3w/worse_runtimes.png)  

```
橫軸為n，代表資料量大小；y軸表示時間。  
```


## Sorting排序
當資料被有效的排序後，可以加速我們處理資料的效率。從week0的電話簿例子中就可以發現，若排序資料可協助我們直接更有效率的推測出特定資料所在的位置。所以接下來介紹幾種排序方式：  

### Bubble_Sort
* **原理與介紹**：  
**氣泡排序法**，這是一種簡單的排序演算法，又稱**冒泡排序**。它重複地走訪過要排序的數列，一次比較兩個元素，如果他們的順序錯誤就把他們交換過來。走訪數列的工作是重複地進行直到沒有再需要交換，也就是說該數列已經排序完成。
* **步驟**：
 1. 比較相鄰的元素。如果第一個比第二個大，就交換他們兩個。
 2. 對每一對相鄰元素作同樣的工作，從開始第一對到結尾的最後一對。這步做完後，最後的元素會是最大的數。
 3. 針對所有的元素重複以上的步驟，除了最後一個。
 4. 持續每次對越來越少的元素重複上面的步驟，直到沒有任何一對數字需要比較。
* **時間複雜度（最壞）**：O(n^2)  
原因：最壞的情況是n個數值為完全亂序，即左到右為大到小排列。為了將最小值移至最左側，我們需將所有數值走訪過n次。因此運行時間為n^2次。
* **示意圖**：


![image](https://i.imgur.com/9V8xxtj.gif)  
> 圖片來源：https://pjchender.blogspot.com/2017/09/bubble-sort.html

### Selection_Sort
* **原理與介紹**：  
**選擇排序法**，一種簡單直觀的排序演算法。每次交換一對元素，他們當中至少一個會被移到其最終位置上，所以選擇排序法的優點是如果某個元素已經在正確的最終位置，則他不會被移動。
* **步驟**：
 1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
 2. 從剩餘未排序元素中繼續尋找最小（大）元素，然後放到已排序序列的末尾
 3. 重複執行上述動作，直到所有元素均排序完畢。
* **時間複雜度（最壞）**：O(n^2)  
原因：對n個元素的表進行排序總共進行至多n-1次交換。第一次演練執行n-1次；第二次演練中，因為我們知道最左邊的值已經在正確位置，所以我們從最左邊的第二個開始，執行n-2次；第三次演練中執行n-3次，以此類推。因此我們的總運行時間為(n-1)+(n-2)+(n-3)+....共是(n(n-1))/2次。雖該數字低於n^2，但若n非常大時，我們也可說選擇排序的運行時間是n^2。
* **示意圖**：


![image](https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif) 
> 圖片來源：https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F

### Insertion_Sort
* **原理與介紹**：  
**插入排序法**，通過構建有序序列，對於未排序資料，在已排序序列中從後向前掃描，找到相應位置並插入。在實作上通常採用in-place排序（只需用到O(1)的額外空間的排序）。
* **步驟**：
 1. 從第一個元素開始，該元素可以認為已經被排序
 2. 取出下一個元素，在已經排序的元素序列中從後向前掃描
 3. 如果該元素（已排序）大於新元素，將該元素移到下一位置
 4. 重複步驟3，直到找到已排序的元素小於或者等於新元素的位置
 5. 將新元素插入到該位置後，重複步驟2~5
* **時間複雜度（最壞）**：O(n^2)  
原因：最壞的情況下，每次需要插入數字時，我們都必須移位整個排序列表。所以最壞時間複雜度為n^2。
* **示意圖**：


![image](https://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Insertion-sort-example-300px.gif/220px-Insertion-sort-example-300px.gif)  
> 圖片來源：https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F

* **舉例**：影片中採用4261375這個數列為例，在檢查每個元素時，將其位置放在左側列表中的正確位置。該左側列表稱為排序列表（實際上還是跟為排序的數字放在同一個序列）。  
以下是影片中插入排序美執行完一次後的結果流程：  
（斜線代表左右列表的分隔，斜線以佐為排序列表）   
```
/ 4 2 6 1 3 7 5  
4 / 2 6 1 3 7 5  
2 4 / 6 1 3 7 5  
2 4 6 / 1 3 7 5  
1 2 4 6 / 3 7 5  
1 2 3 4 6 / 7 5  
1 2 3 4 5 6 / 7  
1 2 3 4 5 6 7 /  
```

## O與Ω符號
* **O符號**：表示**最壞情況下的運行時間**。
* **Ω符號**：表示**最佳情況下的運行時間**。


## Reference
https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6  
https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F  
https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F  
https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F  
